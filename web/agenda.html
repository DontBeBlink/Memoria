<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Memoria Agenda</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0f172a" />
  <link rel="icon" href="../favicon.svg" type="image/svg+xml" />
  <link rel="manifest" href="../manifest.json" />
  <link rel="apple-touch-icon" href="../icons/icon-192.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b1220; color:#e5e7eb; }
    header { padding:12px 16px; background:#111827; position:sticky; top:0; display:flex; align-items:center; gap:12px; }
    h1 { margin:0; font-size:18px; }
    main { padding:16px; max-width:840px; margin: 0 auto; }
    section { margin-bottom: 20px; }
    form { display:flex; gap:8px; flex-wrap:wrap; }
    input[type=text] { flex:1; min-width: 240px; padding:10px; border-radius:8px; border:1px solid #374151; background:#0f172a; color:#e5e7eb; }
    button, select { padding:10px 12px; border:0; border-radius:8px; background:#2563eb; color:white; }
    .muted { color:#9ca3af; font-size:12px; }
    ul { list-style:none; padding:0; margin:0; display:grid; gap:8px; }
    li { border:1px solid #374151; border-radius:8px; padding:10px 12px; background:#0f172a; display:flex; justify-content:space-between; align-items:center; gap:8px; }
    li.editing { border-color:#2563eb; }
    li.unsaved { border-color:#f59e0b; }
    .row { display:flex; gap:8px; align-items:center; }
    .edit-icon { 
      background:none; border:none; color:#9ca3af; cursor:pointer; padding:4px; border-radius:4px;
      display:inline-flex; align-items:center; justify-content:center; font-size:14px;
    }
    .edit-icon:hover { background:#374151; color:#e5e7eb; }
    .edit-actions { display:flex; gap:4px; }
    .edit-actions button { padding:4px 8px; font-size:12px; }
    .save-btn { background:#059669; }
    .cancel-btn { background:#dc2626; }
    .inline-input { 
      background:#1f2937; border:1px solid #374151; color:#e5e7eb; padding:6px 8px; 
      border-radius:4px; font-size:14px; width:100%; min-width:200px;
    }
    .inline-input:focus { outline:none; border-color:#2563eb; }
    .error-message { color:#ef4444; font-size:12px; margin-top:4px; }
    .tags { color:#9ca3af; font-size:12px; }
    .pill { background:#1f2937; color:#e5e7eb; border-radius:999px; padding:4px 8px; font-size:12px; }
    .sec-title { display:flex; justify-content:space-between; align-items:center; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 720px) { .grid { grid-template-columns: 1fr; } }
    
    /* Agenda-specific styles */
    .agenda-tabs { display:flex; gap:8px; margin-bottom:16px; }
    .agenda-tab { 
      padding:8px 16px; border:1px solid #374151; border-radius:6px; background:#0f172a; 
      color:#9ca3af; cursor:pointer; transition:all 0.2s;
    }
    .agenda-tab.active { background:#2563eb; color:white; border-color:#2563eb; }
    .agenda-tab:hover:not(.active) { background:#374151; color:#e5e7eb; }
    
    .agenda-view { display:none; }
    .agenda-view.active { display:block; }
    
    .time-group { margin-bottom:16px; }
    .time-group h4 { 
      margin:0 0 8px 0; color:#60a5fa; font-size:14px; font-weight:500;
      padding:4px 8px; background:#1f2937; border-radius:4px; display:inline-block;
    }
    
    .quick-actions { display:flex; gap:4px; margin-left:8px; }
    .quick-action { 
      padding:2px 6px; font-size:11px; border-radius:4px; 
      background:#374151; color:#e5e7eb; border:none; cursor:pointer;
    }
    .quick-action:hover { background:#4b5563; }
    .quick-action.done { background:#059669; }
    .quick-action.reschedule { background:#f59e0b; }
    
    .agenda-container { max-width:1000px; margin:0 auto; }
    .auth-warning { background:#dc2626; color:white; padding:12px 16px; display:none; border-left:4px solid #b91c1c; }
    .auth-warning.show { display:block; }
    .nav-links a { color:#60a5fa; text-decoration:none; padding:8px 12px; border:1px solid #374151; border-radius:6px; font-size:14px; }
    .nav-links a:hover { text-decoration:underline; }
    
    /* Search and filter specific styles */
    .search-active { border-color:#f59e0b !important; }
    .unscheduled-mode .agenda-tab { opacity:0.5; }
    .unscheduled-mode .agenda-tab.active { opacity:1; background:#f59e0b; border-color:#f59e0b; }
    .filter-indicator { 
      display:inline-block; background:#f59e0b; color:white; 
      padding:2px 6px; border-radius:3px; font-size:11px; margin-left:8px;
    }
    
    /* Recurring task badge */
    .recurring-badge {
      display:inline-block; background:#8b5cf6; color:white;
      padding:2px 6px; border-radius:3px; font-size:10px; margin-left:8px;
      font-weight:500;
    }
    
    /* Recurrence form styles */
    .recurrence-active { background:#374151 !important; color:#e5e7eb !important; }
    
    /* Priority indicators */
    .priority-badge {
      display:inline-block; padding:2px 6px; border-radius:3px; 
      font-size:10px; margin-left:8px; font-weight:500;
    }
    .priority-high { background:#dc2626; color:white; }
    .priority-medium { background:#f59e0b; color:white; }
    .priority-low { background:#059669; color:white; }
    
    /* Priority-based task styling */
    .task-high-priority { border-left: 4px solid #dc2626; }
    .task-medium-priority { border-left: 4px solid #f59e0b; }
    .task-low-priority { border-left: 4px solid #059669; }
    
    /* Timeline and drag-drop styles */
    .timeline-container { 
      display: grid; 
      grid-template-columns: 80px 1fr; 
      gap: 8px; 
      margin-top: 16px;
    }
    .timeline-hours {
      display: flex;
      flex-direction: column;
    }
    .timeline-content {
      position: relative;
      border-left: 2px solid #374151;
    }
    .time-slot {
      height: 60px;
      border-bottom: 1px solid #374151;
      position: relative;
      display: flex;
      align-items: center;
      padding: 4px 8px;
      transition: background-color 0.2s;
    }
    .time-slot:hover {
      background-color: #1f2937;
    }
    .time-slot.drag-over {
      background-color: #2563eb !important;
      border: 2px dashed #60a5fa;
    }
    .time-label {
      font-size: 12px;
      color: #9ca3af;
      text-align: right;
      padding: 4px 8px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      border-bottom: 1px solid #374151;
    }
    .timeline-task {
      position: absolute;
      left: 8px;
      right: 8px;
      background: #0f172a;
      border: 1px solid #374151;
      border-radius: 6px;
      padding: 8px;
      cursor: move;
      z-index: 10;
      min-height: 40px;
      display: flex;
      align-items: center;
      transition: all 0.2s;
    }
    .timeline-task:hover {
      background: #1f2937;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .timeline-task.dragging {
      opacity: 0.6;
      transform: rotate(2deg);
      z-index: 1000;
    }
    .timeline-task .task-content {
      flex: 1;
      font-size: 14px;
    }
    .timeline-task .task-time {
      font-size: 11px;
      color: #9ca3af;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <header id="header"></header>
  <div id="authWarningContainer"></div>
  <main>
    <div class="agenda-container">
      <!-- Add Task Form -->
      <section style="margin-bottom:20px;">
        <form id="taskForm">
          <div class="row">
            <input id="taskText" type="text" placeholder="Add a task... (try 'Meeting Mon 9a' or 'Call client in 2h')" required style="flex:1;" />
            <select id="prioritySelect" style="padding:10px 12px; border-radius:8px; background:#0f172a; color:#e5e7eb; border:1px solid #374151; min-width:100px;">
              <option value="low">üü¢ Low</option>
              <option value="medium" selected>üü° Medium</option>
              <option value="high">üî¥ High</option>
            </select>
            <button type="button" id="repeatToggle" style="background:#374151; color:#9ca3af;">üîÅ Repeat</button>
            <button type="submit">Add</button>
          </div>
          
          <!-- Recurrence Options (initially hidden) -->
          <div id="recurrenceOptions" style="display:none; margin-top:8px; padding:12px; border:1px solid #374151; border-radius:8px; background:#1f2937;">
            <div class="row" style="margin-bottom:8px;">
              <label style="color:#9ca3af; font-size:14px;">Repeat:</label>
              <select id="recurrenceType" style="padding:4px 8px; border-radius:4px; background:#0f172a; color:#e5e7eb; border:1px solid #374151;">
                <option value="">No repeat</option>
                <option value="FREQ=DAILY">Daily</option>
                <option value="FREQ=WEEKLY">Weekly</option>
                <option value="FREQ=MONTHLY">Monthly</option>
                <option value="custom">Custom RRULE</option>
              </select>
            </div>
            <input id="customRrule" type="text" placeholder="Custom RRULE (e.g., FREQ=WEEKLY;BYDAY=MO,WE,FR)" style="display:none; width:100%; padding:6px 8px; border-radius:4px; background:#0f172a; color:#e5e7eb; border:1px solid #374151; font-size:12px;" />
            <div class="row" style="margin-top:8px; font-size:12px; color:#6b7280;">
              <span>üí° Tip: Set a due date first, then configure repeat pattern</span>
            </div>
          </div>
        </form>
      </section>

      <!-- Search and Filter -->
      <section style="margin-bottom:20px;">
        <div class="row">
          <input id="searchInput" type="text" placeholder="Search tasks..." style="flex:1;" />
          <button id="clearSearch">Clear</button>
          <button id="viewUnscheduled">View Unscheduled</button>
        </div>
      </section>

      <!-- View Tabs -->
      <div class="agenda-tabs">
        <div class="agenda-tab active" data-view="day">üìÖ Day</div>
        <div class="agenda-tab" data-view="week">üìÜ Week</div>
      </div>

      <!-- Day View -->
      <div id="dayView" class="agenda-view active">
        <div class="sec-title" style="margin-bottom:16px;">
          <h3 id="dayTitle">Today</h3>
          <div class="row">
            <button id="prevDay">&lt;</button>
            <button id="nextDay">&gt;</button>
            <button id="todayBtn">Today</button>
            <button id="timelineToggle" style="background:#374151; color:#9ca3af;">üìÖ Timeline</button>
          </div>
        </div>
        <div id="dayContent"></div>
      </div>

      <!-- Week View -->
      <div id="weekView" class="agenda-view">
        <div class="sec-title" style="margin-bottom:16px;">
          <h3 id="weekTitle">This Week</h3>
          <div class="row">
            <button id="prevWeek">&lt;</button>
            <button id="nextWeek">&gt;</button>
            <button id="thisWeekBtn">This Week</button>
          </div>
        </div>
        <div id="weekContent"></div>
      </div>

      <!-- Quick Plan Section (preserved) -->
      <section style="margin-top:32px; padding-top:16px; border-top:1px solid #374151;">
        <div class="sec-title">
          <h3>üéØ Quick Plan</h3>
          <span class="muted">AI suggestions based on energy</span>
        </div>
        <div class="row" style="margin-bottom:8px;">
          <select id="energy">
            <option value="low">Low</option>
            <option value="med" selected>Medium</option>
            <option value="high">High</option>
          </select>
          <button id="suggest">Suggest</button>
        </div>
        <ul id="planList"></ul>
      </section>
    </div>
    <p class="muted">Tip: Add this page to your Home Screen for app-like use. Notifications: use ntfy to get alerts on your phone when tasks are due.</p>
  </main>

  <script src="js/api.js"></script>
  <script src="js/ui.js"></script>
  <script>
    // Set current page for navigation
    window.memoriaUI.setCurrentPage('agenda');
    
    // Render header and auth warning
    const header = document.getElementById('header');
    const authContainer = document.getElementById('authWarningContainer');
    
    window.memoriaUI.renderHeader(header);
    const authWarning = window.memoriaUI.renderAuthWarning(authContainer);

    // Initialize page elements
    const taskForm = document.getElementById('taskForm');
    const taskText = document.getElementById('taskText');
    const prioritySelect = document.getElementById('prioritySelect');
    const repeatToggle = document.getElementById('repeatToggle');
    const recurrenceOptions = document.getElementById('recurrenceOptions');
    const recurrenceType = document.getElementById('recurrenceType');
    const customRrule = document.getElementById('customRrule');
    const searchInput = document.getElementById('searchInput');
    const clearSearchBtn = document.getElementById('clearSearch');
    const viewUnscheduledBtn = document.getElementById('viewUnscheduled');
    const energySel = document.getElementById('energy');
    const suggestBtn = document.getElementById('suggest');
    const planList = document.getElementById('planList');

    // Tab elements
    const tabs = document.querySelectorAll('.agenda-tab');
    const dayView = document.getElementById('dayView');
    const weekView = document.getElementById('weekView');
    
    // Navigation elements
    const dayTitle = document.getElementById('dayTitle');
    const weekTitle = document.getElementById('weekTitle');
    const dayContent = document.getElementById('dayContent');
    const weekContent = document.getElementById('weekContent');
    
    // Day navigation
    const prevDayBtn = document.getElementById('prevDay');
    const nextDayBtn = document.getElementById('nextDay');
    const todayBtn = document.getElementById('todayBtn');
    const timelineToggle = document.getElementById('timelineToggle');
    
    // Week navigation
    const prevWeekBtn = document.getElementById('prevWeek');
    const nextWeekBtn = document.getElementById('nextWeek');
    const thisWeekBtn = document.getElementById('thisWeekBtn');

    // Current view state
    let currentView = 'day';
    let currentDate = new Date();
    let searchQuery = '';
    let showingUnscheduled = false;
    let timelineMode = false;
    
    // Utility functions
    function formatDate(date) {
      return date.toISOString().split('T')[0];
    }
    
    function formatDateTime(date) {
      return date.toISOString();
    }
    
    function addDays(date, days) {
      const result = new Date(date);
      result.setDate(result.getDate() + days);
      return result;
    }
    
    function addHours(date, hours) {
      const result = new Date(date);
      result.setTime(result.getTime() + (hours * 60 * 60 * 1000));
      return result;
    }
    
    function getWeekStart(date) {
      const result = new Date(date);
      const day = result.getDay();
      const diff = result.getDate() - day;
      return new Date(result.setDate(diff));
    }
    
    function getWeekEnd(date) {
      const weekStart = getWeekStart(date);
      return addDays(weekStart, 6);
    }

    // Task management functions
    async function loadTasks(start, end) {
      const params = new URLSearchParams({ open_only: 'true' });
      if (start && !showingUnscheduled) params.append('start', start);
      if (end && !showingUnscheduled) params.append('end', end);
      
      try {
        let tasks = await window.memoriaAPI.request(`/tasks?${params}`);
        
        // Filter by search query if provided
        if (searchQuery) {
          tasks = tasks.filter(task => 
            task.title.toLowerCase().includes(searchQuery.toLowerCase())
          );
        }
        
        // Filter unscheduled tasks if requested
        if (showingUnscheduled) {
          tasks = tasks.filter(task => !task.due);
        }
        
        // Sort tasks by due date
        tasks.sort((a, b) => {
          if (!a.due && !b.due) return 0;
          if (!a.due) return 1;
          if (!b.due) return -1;
          return new Date(a.due) - new Date(b.due);
        });
        
        return tasks;
      } catch (error) {
        console.error('Failed to load tasks:', error);
        return [];
      }
    }

    async function rescheduleTask(taskId, newDue) {
      try {
        await window.memoriaAPI.request(`/tasks/${taskId}`, 'PATCH', { due: newDue });
        await refreshCurrentView();
      } catch (error) {
        console.error('Failed to reschedule task:', error);
      }
    }

    async function markTaskDone(taskId) {
      try {
        await window.memoriaAPI.request(`/tasks/${taskId}`, 'PATCH', { done: true });
        await refreshCurrentView();
      } catch (error) {
        console.error('Failed to mark task done:', error);
      }
    }

    // Task management functions
    async function deleteTask(taskId, isRecurring, isInstance) {
      try {
        if (isRecurring && !isInstance) {
          // Deleting a recurring task (parent)
          const confirm = window.confirm(
            'This will delete the entire recurring task series. Are you sure?'
          );
          if (!confirm) return;
        } else if (isInstance) {
          // Deleting a recurring task instance
          const confirm = window.confirm(
            'Delete this single occurrence? The recurring series will continue.'
          );
          if (!confirm) return;
        } else {
          // Regular task deletion
          const confirm = window.confirm('Delete this task?');
          if (!confirm) return;
        }
        
        await window.memoriaAPI.request(`/tasks/${taskId}`, 'DELETE');
        await refreshCurrentView();
      } catch (error) {
        console.error('Failed to delete task:', error);
        alert('Failed to delete task');
      }
    }

    async function editTask(task) {
      try {
        // Create edit form
        const newTitle = prompt('Edit task title:', task.title);
        if (newTitle === null) return; // User cancelled
        
        const updates = { title: newTitle };
        
        // Ask about due date
        const currentDue = task.due ? new Date(task.due).toISOString().slice(0, 16) : '';
        const newDue = prompt('Edit due date (YYYY-MM-DDTHH:MM, leave empty for no due date):', currentDue);
        if (newDue !== null) {
          updates.due = newDue || null;
        }
        
        // Ask about priority
        const currentPriority = task.priority || 'medium';
        const priorityChoice = prompt('Edit priority (high, medium, low):', currentPriority);
        if (priorityChoice !== null && ['high', 'medium', 'low'].includes(priorityChoice.toLowerCase())) {
          updates.priority = priorityChoice.toLowerCase();
        }
        
        // Handle recurrence editing for recurring tasks
        if (task.rrule || task.is_recurring_instance) {
          if (task.is_recurring_instance) {
            const editSeries = confirm('Edit the entire recurring series? (Cancel to edit only this instance)');
            if (editSeries) {
              // For instances, we can't directly edit the parent task easily
              alert('Editing recurring series from instances is not yet supported. Please edit the original task.');
              return;
            }
          } else {
            // Editing parent recurring task
            const currentRrule = task.rrule || '';
            const newRrule = prompt('Edit recurrence rule (RRULE format, leave empty to remove recurrence):', currentRrule);
            if (newRrule !== null) {
              updates.rrule = newRrule || null;
            }
          }
        }
        
        await window.memoriaAPI.request(`/tasks/${task.id}`, 'PATCH', updates);
        await refreshCurrentView();
      } catch (error) {
        console.error('Failed to edit task:', error);
        alert('Failed to edit task');
      }
    }

    // Quick action handlers
    function createQuickActions(task) {
      const actions = document.createElement('div');
      actions.className = 'quick-actions';
      
      const doneBtn = document.createElement('button');
      doneBtn.className = 'quick-action done';
      doneBtn.textContent = 'Done';
      doneBtn.onclick = () => markTaskDone(task.id);
      
      const editBtn = document.createElement('button');
      editBtn.className = 'quick-action';
      editBtn.style.background = '#6366f1';
      editBtn.textContent = '‚úèÔ∏è Edit';
      editBtn.onclick = () => editTask(task);
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'quick-action';
      deleteBtn.style.background = '#dc2626';
      deleteBtn.textContent = 'üóëÔ∏è Delete';
      deleteBtn.onclick = () => deleteTask(task.id, !!task.rrule, !!task.is_recurring_instance);
      
      const oneHourBtn = document.createElement('button');
      oneHourBtn.className = 'quick-action reschedule';
      oneHourBtn.textContent = '+1h';
      oneHourBtn.onclick = () => {
        const newDue = task.due ? addHours(new Date(task.due), 1) : addHours(new Date(), 1);
        rescheduleTask(task.id, formatDateTime(newDue));
      };
      
      const oneDayBtn = document.createElement('button');
      oneDayBtn.className = 'quick-action reschedule';
      oneDayBtn.textContent = '+1d';
      oneDayBtn.onclick = () => {
        const newDue = task.due ? addDays(new Date(task.due), 1) : addDays(new Date(), 1);
        rescheduleTask(task.id, formatDateTime(newDue));
      };
      
      const nextWeekBtn = document.createElement('button');
      nextWeekBtn.className = 'quick-action reschedule';
      nextWeekBtn.textContent = 'Next week';
      nextWeekBtn.onclick = () => {
        const newDue = task.due ? addDays(new Date(task.due), 7) : addDays(new Date(), 7);
        rescheduleTask(task.id, formatDateTime(newDue));
      };
      
      const pickDateBtn = document.createElement('button');
      pickDateBtn.className = 'quick-action reschedule';
      pickDateBtn.textContent = 'Pick date';
      pickDateBtn.onclick = () => {
        const currentDue = task.due ? new Date(task.due).toISOString().slice(0, 16) : '';
        const newDateTime = prompt('Enter new date and time (YYYY-MM-DDTHH:MM):', currentDue);
        if (newDateTime) {
          try {
            const newDue = new Date(newDateTime);
            rescheduleTask(task.id, formatDateTime(newDue));
          } catch (error) {
            alert('Invalid date format');
          }
        }
      };
      
      actions.append(doneBtn, editBtn, deleteBtn, oneHourBtn, oneDayBtn, nextWeekBtn, pickDateBtn);
      return actions;
    }

    // Render task item
    function renderTask(task) {
      const li = document.createElement('li');
      
      // Add priority-based border styling
      const priority = task.priority || 'medium';
      li.className = `task-${priority}-priority`;
      
      const left = document.createElement('div');
      left.style.flex = '1';
      
      const title = document.createElement('div');
      title.textContent = task.title;
      title.className = 'content-text';
      
      // Add priority badge
      if (task.priority) {
        const priorityBadge = document.createElement('span');
        priorityBadge.className = `priority-badge priority-${task.priority}`;
        const priorityText = {
          'high': 'üî¥ High',
          'medium': 'üü° Medium', 
          'low': 'üü¢ Low'
        };
        priorityBadge.textContent = priorityText[task.priority] || 'üü° Medium';
        priorityBadge.title = `Priority: ${task.priority}`;
        title.appendChild(priorityBadge);
      }
      
      // Add recurring badge if task has rrule
      if (task.rrule) {
        const badge = document.createElement('span');
        badge.className = 'recurring-badge';
        badge.textContent = 'üîÅ Recurring';
        badge.title = `RRULE: ${task.rrule}`;
        title.appendChild(badge);
      }
      
      // Add instance indicator for recurring task instances
      if (task.is_recurring_instance) {
        const instanceBadge = document.createElement('span');
        instanceBadge.className = 'recurring-badge';
        instanceBadge.style.background = '#059669';
        instanceBadge.textContent = '‚Üª Instance';
        instanceBadge.title = `Instance of recurring task #${task.parent_task_id}`;
        title.appendChild(instanceBadge);
      }
      
      const meta = document.createElement('div');
      meta.className = 'tags';
      const dueText = task.due ? new Date(task.due).toLocaleString() : 'No due date';
      meta.textContent = dueText + (task.tags ? ' ' + task.tags : '');
      
      left.append(title, meta);
      
      const right = createQuickActions(task);
      
      li.append(left, right);
      return li;
    }

    // Timeline drag and drop functions
    function createTimelineTask(task) {
      const taskElement = document.createElement('div');
      taskElement.className = `timeline-task task-${task.priority || 'medium'}-priority`;
      taskElement.draggable = true;
      taskElement.dataset.taskId = task.id;
      
      const content = document.createElement('div');
      content.className = 'task-content';
      content.textContent = task.title;
      
      // Add priority badge
      if (task.priority) {
        const priorityBadge = document.createElement('span');
        priorityBadge.className = `priority-badge priority-${task.priority}`;
        const priorityText = {
          'high': 'üî¥',
          'medium': 'üü°', 
          'low': 'üü¢'
        };
        priorityBadge.textContent = priorityText[task.priority] || 'üü°';
        priorityBadge.style.marginLeft = '8px';
        content.appendChild(priorityBadge);
      }
      
      const timeElement = document.createElement('div');
      timeElement.className = 'task-time';
      timeElement.textContent = new Date(task.due).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      
      taskElement.appendChild(content);
      taskElement.appendChild(timeElement);
      
      // Add drag event listeners
      taskElement.addEventListener('dragstart', handleDragStart);
      taskElement.addEventListener('dragend', handleDragEnd);
      
      return taskElement;
    }
    
    function handleDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.taskId);
      e.target.classList.add('dragging');
    }
    
    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
    }
    
    function handleDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }
    
    function handleDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }
    
    async function handleDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');
      
      const taskId = e.dataTransfer.getData('text/plain');
      const targetHour = parseInt(e.currentTarget.dataset.hour);
      
      // Calculate new due date/time
      const newDate = new Date(currentDate);
      newDate.setHours(targetHour, 0, 0, 0);
      
      try {
        await rescheduleTask(taskId, formatDateTime(newDate));
      } catch (error) {
        console.error('Failed to reschedule task:', error);
        alert('Failed to reschedule task');
      }
    }

    // Day view functions
    async function renderDayView() {
      if (showingUnscheduled) {
        await renderUnscheduledView();
        return;
      }
      
      const start = formatDate(currentDate) + 'T00:00:00';
      const end = formatDate(currentDate) + 'T23:59:59';
      const tasks = await loadTasks(start, end);
      
      dayTitle.textContent = searchQuery ? 
        `${currentDate.toDateString()} (filtered)` : 
        currentDate.toDateString();
      dayContent.innerHTML = '';
      
      if (timelineMode) {
        renderTimelineView(tasks);
      } else {
        renderListView(tasks);
      }
    }
    
    function renderTimelineView(tasks) {
      // Create timeline container
      const timelineContainer = document.createElement('div');
      timelineContainer.className = 'timeline-container';
      
      const hoursColumn = document.createElement('div');
      hoursColumn.className = 'timeline-hours';
      
      const contentColumn = document.createElement('div');
      contentColumn.className = 'timeline-content';
      
      // Generate time slots (6 AM to 11 PM)
      for (let hour = 6; hour <= 23; hour++) {
        const timeLabel = document.createElement('div');
        timeLabel.className = 'time-label';
        timeLabel.textContent = `${hour % 12 === 0 ? 12 : hour % 12}${hour < 12 ? 'AM' : 'PM'}`;
        hoursColumn.appendChild(timeLabel);
        
        const timeSlot = document.createElement('div');
        timeSlot.className = 'time-slot';
        timeSlot.dataset.hour = hour;
        timeSlot.addEventListener('dragover', handleDragOver);
        timeSlot.addEventListener('drop', handleDrop);
        timeSlot.addEventListener('dragleave', handleDragLeave);
        contentColumn.appendChild(timeSlot);
      }
      
      // Position tasks in timeline
      for (const task of tasks) {
        if (task.due) {
          const taskDate = new Date(task.due);
          const hour = taskDate.getHours();
          const minutes = taskDate.getMinutes();
          
          if (hour >= 6 && hour <= 23) {
            const taskElement = createTimelineTask(task);
            const slotIndex = hour - 6;
            const topOffset = (minutes / 60) * 60; // Position within the hour slot
            taskElement.style.top = `${slotIndex * 60 + topOffset}px`;
            contentColumn.appendChild(taskElement);
          }
        }
      }
      
      timelineContainer.appendChild(hoursColumn);
      timelineContainer.appendChild(contentColumn);
      dayContent.appendChild(timelineContainer);
    }
    
    function renderListView(tasks) {
      // Group tasks by hour
      const hourGroups = {};
      const noTimeGroup = [];
      
      for (const task of tasks) {
        if (task.due) {
          const hour = new Date(task.due).getHours();
          const hourKey = `${hour.toString().padStart(2, '0')}:00`;
          if (!hourGroups[hourKey]) hourGroups[hourKey] = [];
          hourGroups[hourKey].push(task);
        } else {
          noTimeGroup.push(task);
        }
      }
      
      // Sort tasks within each hour group by minute
      Object.values(hourGroups).forEach(group => {
        group.sort((a, b) => new Date(a.due) - new Date(b.due));
      });
      
      // Render time groups
      const sortedHours = Object.keys(hourGroups).sort();
      for (const hour of sortedHours) {
        const timeGroup = document.createElement('div');
        timeGroup.className = 'time-group';
        
        const timeHeader = document.createElement('h4');
        timeHeader.textContent = hour;
        timeGroup.append(timeHeader);
        
        const taskList = document.createElement('ul');
        for (const task of hourGroups[hour]) {
          taskList.append(renderTask(task));
        }
        timeGroup.append(taskList);
        dayContent.append(timeGroup);
      }
      
      // Render tasks without specific time
      if (noTimeGroup.length > 0) {
        const timeGroup = document.createElement('div');
        timeGroup.className = 'time-group';
        
        const timeHeader = document.createElement('h4');
        timeHeader.textContent = 'No specific time';
        timeGroup.append(timeHeader);
        
        const taskList = document.createElement('ul');
        for (const task of noTimeGroup) {
          taskList.append(renderTask(task));
        }
        timeGroup.append(taskList);
        dayContent.append(timeGroup);
      }
      
      if (tasks.length === 0) {
        const message = searchQuery ? 'No tasks found matching your search' : 'No tasks for this day';
        dayContent.innerHTML = `<p class="muted">${message}</p>`;
      }
    }

    // Week view functions
    async function renderWeekView() {
      if (showingUnscheduled) {
        await renderUnscheduledView();
        return;
      }
      
      const weekStart = getWeekStart(currentDate);
      const weekEnd = getWeekEnd(currentDate);
      
      const start = formatDate(weekStart) + 'T00:00:00';
      const end = formatDate(weekEnd) + 'T23:59:59';
      const tasks = await loadTasks(start, end);
      
      const weekStartStr = weekStart.toLocaleDateString();
      const weekEndStr = weekEnd.toLocaleDateString();
      weekTitle.textContent = searchQuery ? 
        `${weekStartStr} - ${weekEndStr} (filtered)` : 
        `${weekStartStr} - ${weekEndStr}`;
      
      weekContent.innerHTML = '';
      
      // Group tasks by day
      const dayGroups = {};
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      
      for (let i = 0; i < 7; i++) {
        const day = addDays(weekStart, i);
        const dayKey = formatDate(day);
        const dayName = dayNames[day.getDay()];
        const displayName = `${dayName} ${day.getDate()}`;
        dayGroups[displayName] = { date: dayKey, tasks: [] };
      }
      
      for (const task of tasks) {
        if (task.due) {
          const taskDate = formatDate(new Date(task.due));
          const dayEntry = Object.entries(dayGroups).find(([_, data]) => data.date === taskDate);
          if (dayEntry) {
            dayEntry[1].tasks.push(task);
          }
        }
      }
      
      // Sort tasks within each day by time
      Object.values(dayGroups).forEach(group => {
        group.tasks.sort((a, b) => new Date(a.due) - new Date(b.due));
      });
      
      // Render day groups
      for (const [dayName, data] of Object.entries(dayGroups)) {
        if (data.tasks.length > 0) {
          const timeGroup = document.createElement('div');
          timeGroup.className = 'time-group';
          
          const timeHeader = document.createElement('h4');
          timeHeader.textContent = dayName;
          timeGroup.append(timeHeader);
          
          const taskList = document.createElement('ul');
          for (const task of data.tasks) {
            taskList.append(renderTask(task));
          }
          timeGroup.append(taskList);
          weekContent.append(timeGroup);
        }
      }
      
      if (tasks.length === 0) {
        const message = searchQuery ? 'No tasks found matching your search' : 'No tasks for this week';
        weekContent.innerHTML = `<p class="muted">${message}</p>`;
      }
    }

    // Unscheduled view function
    async function renderUnscheduledView() {
      const tasks = await loadTasks();
      const container = currentView === 'day' ? dayContent : weekContent;
      const titleElement = currentView === 'day' ? dayTitle : weekTitle;
      
      titleElement.textContent = searchQuery ? 
        'Unscheduled Tasks (filtered)' : 
        'Unscheduled Tasks';
      container.innerHTML = '';
      
      if (tasks.length > 0) {
        const timeGroup = document.createElement('div');
        timeGroup.className = 'time-group';
        
        const timeHeader = document.createElement('h4');
        timeHeader.textContent = `${tasks.length} unscheduled task${tasks.length === 1 ? '' : 's'}`;
        timeGroup.append(timeHeader);
        
        const taskList = document.createElement('ul');
        for (const task of tasks) {
          taskList.append(renderTask(task));
        }
        timeGroup.append(taskList);
        container.append(timeGroup);
      } else {
        const message = searchQuery ? 
          'No unscheduled tasks found matching your search' : 
          'No unscheduled tasks';
        container.innerHTML = `<p class="muted">${message}</p>`;
      }
    }

    // View management
    function switchView(view) {
      currentView = view;
      showingUnscheduled = false; // Reset unscheduled view when switching tabs
      
      // Update tab states
      tabs.forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === view);
      });
      
      // Update view visibility
      dayView.classList.toggle('active', view === 'day');
      weekView.classList.toggle('active', view === 'week');
      
      refreshCurrentView();
    }

    async function refreshCurrentView() {
      if (currentView === 'day') {
        await renderDayView();
      } else {
        await renderWeekView();
      }
    }

    // Event handlers
    tabs.forEach(tab => {
      tab.onclick = () => switchView(tab.dataset.view);
    });

    prevDayBtn.onclick = () => {
      currentDate = addDays(currentDate, -1);
      renderDayView();
    };

    nextDayBtn.onclick = () => {
      currentDate = addDays(currentDate, 1);
      renderDayView();
    };

    todayBtn.onclick = () => {
      currentDate = new Date();
      renderDayView();
    };
    
    timelineToggle.onclick = () => {
      timelineMode = !timelineMode;
      timelineToggle.textContent = timelineMode ? 'üìã List' : 'üìÖ Timeline';
      timelineToggle.classList.toggle('recurrence-active', timelineMode);
      renderDayView();
    };

    prevWeekBtn.onclick = () => {
      currentDate = addDays(currentDate, -7);
      renderWeekView();
    };

    nextWeekBtn.onclick = () => {
      currentDate = addDays(currentDate, 7);
      renderWeekView();
    };

    thisWeekBtn.onclick = () => {
      currentDate = new Date();
      renderWeekView();
    };

    // Search functionality
    searchInput.oninput = (e) => {
      searchQuery = e.target.value.trim();
      
      // Add visual feedback for active search
      if (searchQuery) {
        searchInput.classList.add('search-active');
      } else {
        searchInput.classList.remove('search-active');
      }
      
      refreshCurrentView();
    };

    clearSearchBtn.onclick = () => {
      searchInput.value = '';
      searchQuery = '';
      showingUnscheduled = false;
      searchInput.classList.remove('search-active');
      document.body.classList.remove('unscheduled-mode');
      viewUnscheduledBtn.textContent = 'View Unscheduled';
      refreshCurrentView();
    };

    viewUnscheduledBtn.onclick = () => {
      showingUnscheduled = !showingUnscheduled;
      viewUnscheduledBtn.textContent = showingUnscheduled ? 'View Scheduled' : 'View Unscheduled';
      
      // Add visual feedback for unscheduled mode
      if (showingUnscheduled) {
        document.body.classList.add('unscheduled-mode');
      } else {
        document.body.classList.remove('unscheduled-mode');
      }
      
      refreshCurrentView();
    };

    // Recurrence toggle functionality
    repeatToggle.onclick = () => {
      const isVisible = recurrenceOptions.style.display !== 'none';
      recurrenceOptions.style.display = isVisible ? 'none' : 'block';
      repeatToggle.classList.toggle('recurrence-active', !isVisible);
    };

    // Recurrence type change handler
    recurrenceType.onchange = () => {
      const isCustom = recurrenceType.value === 'custom';
      customRrule.style.display = isCustom ? 'block' : 'none';
      if (!isCustom) {
        customRrule.value = '';
      }
    };

    taskForm.onsubmit = async (e) => {
      e.preventDefault();
      const title = taskText.value.trim();
      if (!title) return;
      
      // Get recurrence rule
      let rrule = null;
      if (recurrenceType.value === 'custom') {
        rrule = customRrule.value.trim() || null;
      } else if (recurrenceType.value) {
        rrule = recurrenceType.value;
      }
      
      // Get priority
      const priority = prioritySelect.value;
      
      try {
        const taskData = { title, priority };
        if (rrule) {
          taskData.rrule = rrule;
        }
        
        await window.memoriaAPI.request('/tasks', 'POST', taskData);
        taskText.value = '';
        prioritySelect.value = 'medium'; // Reset to default
        recurrenceType.value = '';
        customRrule.value = '';
        recurrenceOptions.style.display = 'none';
        repeatToggle.classList.remove('recurrence-active');
        await refreshCurrentView();
      } catch (error) {
        console.error('Failed to add task:', error);
      }
    };

    // Quick plan functionality (preserved)
    suggestBtn.onclick = async () => {
      const tasks = await window.memoriaAPI.request('/tasks?open_only=true');
      const energy = energySel.value;
      const scored = tasks.map(t => {
        let score = 0;
        if ((t.tags||'').includes('#ydt')) score += 3;
        if (t.due) {
          const d = new Date(t.due);
          const hours = (d - new Date())/36e5;
          if (hours < 0) score += 3;
          else if (hours < 24) score += 2;
          else if (hours < 72) score += 1;
        }
        
        if (energy === 'low') {
          if ((t.tags||'').includes('#easy')) score += 2;
          if ((t.tags||'').includes('#quick')) score += 1;
        } else if (energy === 'high') {
          if ((t.tags||'').includes('#hard')) score += 2;
          if ((t.tags||'').includes('#focus')) score += 1;
        }
        
        return { ...t, score };
      }).sort((a, b) => b.score - a.score);
      
      planList.innerHTML = '';
      const topTasks = scored.slice(0, 5);
      for (const t of topTasks) {
        const li = document.createElement('li');
        li.innerHTML = `
          <div>
            <div>${t.title}</div>
            <div class="tags">Score: ${t.score} ${t.tags||''}</div>
          </div>
        `;
        planList.append(li);
      }
    };

    // Initialize
    renderDayView();
  </script>
</body>
</html>