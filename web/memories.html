<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Memoria Memories</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0f172a" />
  <link rel="icon" href="../favicon.svg" type="image/svg+xml" />
  <link rel="manifest" href="../manifest.json" />
  <link rel="apple-touch-icon" href="../icons/icon-192.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b1220; color:#e5e7eb; }
    header { padding:12px 16px; background:#111827; position:sticky; top:0; display:flex; align-items:center; gap:12px; }
    h1 { margin:0; font-size:18px; }
    main { padding:16px; max-width:840px; margin: 0 auto; }
    section { margin-bottom: 20px; }
    form { display:flex; gap:8px; flex-wrap:wrap; }
    input[type=text] { flex:1; min-width: 240px; padding:10px; border-radius:8px; border:1px solid #374151; background:#0f172a; color:#e5e7eb; }
    button, select { padding:10px 12px; border:0; border-radius:8px; background:#2563eb; color:white; }
    .muted { color:#9ca3af; font-size:12px; }
    ul { list-style:none; padding:0; margin:0; display:grid; gap:8px; }
    li { border:1px solid #374151; border-radius:8px; padding:10px 12px; background:#0f172a; display:flex; justify-content:space-between; align-items:center; gap:8px; }
    li.editing { border-color:#2563eb; }
    li.unsaved { border-color:#f59e0b; }
    .row { display:flex; gap:8px; align-items:center; }
    .edit-icon { 
      background:none; border:none; color:#9ca3af; cursor:pointer; padding:4px; border-radius:4px;
      display:inline-flex; align-items:center; justify-content:center; font-size:14px;
    }
    .edit-icon:hover { background:#374151; color:#e5e7eb; }
    .edit-actions { display:flex; gap:4px; }
    .edit-actions button { padding:4px 8px; font-size:12px; }
    .save-btn { background:#059669; }
    .cancel-btn { background:#dc2626; }
    .inline-input { 
      background:#1f2937; border:1px solid #374151; color:#e5e7eb; padding:6px 8px; 
      border-radius:4px; font-size:14px; width:100%; min-width:200px;
    }
    .inline-input:focus { outline:none; border-color:#2563eb; }
    .error-message { color:#ef4444; font-size:12px; margin-top:4px; }
    .tags { color:#9ca3af; font-size:12px; }
    .pill { background:#1f2937; color:#e5e7eb; border-radius:999px; padding:4px 8px; font-size:12px; }
    .sec-title { display:flex; justify-content:space-between; align-items:center; }
    .auth-warning { background:#dc2626; color:white; padding:12px 16px; display:none; border-left:4px solid #b91c1c; }
    .auth-warning.show { display:block; }
    .mic-button { background:#dc2626; color:white; border-radius:50%; width:44px; height:44px; display:flex; align-items:center; justify-content:center; font-size:18px; cursor:pointer; border:0; transition:all 0.2s; }
    .mic-button:hover { background:#b91c1c; transform:scale(1.05); }
    .mic-button.recording { background:#ef4444; animation:pulse 1s infinite; }
    .mic-button:disabled { background:#6b7280; cursor:not-allowed; }
    @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.7; } }
    .status-message { background:#1f2937; color:#e5e7eb; padding:8px 12px; border-radius:6px; font-size:12px; display:none; margin-left:8px; }
    .nav-links a { color:#60a5fa; text-decoration:none; padding:8px 12px; border:1px solid #374151; border-radius:6px; font-size:14px; }
    .nav-links a:hover { text-decoration:underline; }
    .filter-chips { display:flex; gap:4px; flex-wrap:wrap; margin:8px 0; }
    .chip { background:#374151; color:#e5e7eb; border-radius:999px; padding:4px 8px; font-size:12px; cursor:pointer; border:1px solid transparent; }
    .chip:hover { background:#4b5563; }
    .chip.active { background:#2563eb; border-color:#3b82f6; }
    .chip.removable { padding-right:6px; }
    .chip .remove { margin-left:4px; color:#9ca3af; font-weight:bold; }
    .chip .remove:hover { color:#fff; }
    .bulk-actions { background:#1f2937; border-radius:8px; padding:8px; margin:8px 0; display:none; align-items:center; gap:8px; }
    .bulk-actions.show { display:flex; }
    .select-all-container { margin:8px 0; }
    .memory-checkbox { margin-right:8px; }
    .error-banner { background:#dc2626; color:white; padding:8px 12px; border-radius:6px; margin:8px 0; display:none; }
    .error-banner.show { display:block; }
    .success-banner { background:#059669; color:white; padding:8px 12px; border-radius:6px; margin:8px 0; display:none; }
    .success-banner.show { display:block; }
    .offline-toast { 
      position:fixed; top:72px; right:16px; background:#f59e0b; color:white; 
      padding:12px 16px; border-radius:6px; font-size:14px; z-index:1000;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .queue-indicator { 
      background:#f59e0b; color:white; padding:4px 8px; border-radius:12px; 
      font-size:12px; font-weight:bold; margin-left:8px;
    }
  </style>
</head>
<body>
  <header id="header"></header>
  <div id="authWarningContainer"></div>
  <div id="offlineToastContainer"></div>
  <main>
    <section>
      <div class="sec-title">
        <h3>üìù Memories</h3>
        <span class="muted">All your saved memories</span>
      </div>
      <form id="memForm">
        <input id="memText" type="text" placeholder="What happened today?" required />
        <button type="submit">Add</button>
      </form>
      <div class="row" style="margin:8px 0;">
        <input id="memSearch" type="text" placeholder="Search memories..." style="flex:1;" />
        <button id="memSearchBtn">Search</button>
        <button id="memClearBtn">Clear</button>
      </div>
      
      <!-- Error/Success Banners -->
      <div id="errorBanner" class="error-banner"></div>
      <div id="successBanner" class="success-banner"></div>
      
      <!-- Filter Chips -->
      <div id="filterChips" class="filter-chips"></div>
      
      <!-- Bulk Actions -->
      <div class="select-all-container">
        <label>
          <input type="checkbox" id="selectAll" class="memory-checkbox" />
          Select All
        </label>
      </div>
      <div id="bulkActions" class="bulk-actions">
        <span><span id="selectedCount">0</span> selected</span>
        <button id="bulkDeleteBtn" style="background:#dc2626;">Delete Selected</button>
        <button id="bulkDeselectBtn">Deselect All</button>
      </div>
      <div id="memPagination" class="row" style="justify-content:space-between; margin:8px 0;">
        <button id="memPrevBtn">‚Üê Previous</button>
        <span id="memPageInfo" class="muted">Page 1</span>
        <button id="memNextBtn">Next ‚Üí</button>
      </div>
      <ul id="memList"></ul>
    </section>
  </main>

  <script src="js/api.js"></script>
  <script src="js/ui.js"></script>
  <script src="js/dictation.js"></script>
  <script>
    // Set current page for navigation
    window.memoriaUI.setCurrentPage('memories');
    
    // Render header and auth warning
    const header = document.getElementById('header');
    const authContainer = document.getElementById('authWarningContainer');
    
    window.memoriaUI.renderHeader(header, {
      showMicButton: true,
      onMicButtonClick: initializeDictation
    });
    
    const authWarning = window.memoriaUI.renderAuthWarning(authContainer);
    
    // Render offline toast
    const offlineContainer = document.getElementById('offlineToastContainer');
    const offlineToast = window.memoriaUI.renderOfflineToast(offlineContainer);

    // Initialize page elements
    const memForm = document.getElementById('memForm');
    const memText = document.getElementById('memText');
    const memList = document.getElementById('memList');
    const memSearch = document.getElementById('memSearch');
    const memSearchBtn = document.getElementById('memSearchBtn');
    const memClearBtn = document.getElementById('memClearBtn');
    const memPagination = document.getElementById('memPagination');
    const memPrevBtn = document.getElementById('memPrevBtn');
    const memNextBtn = document.getElementById('memNextBtn');
    const memPageInfo = document.getElementById('memPageInfo');
    const filterChips = document.getElementById('filterChips');
    const selectAll = document.getElementById('selectAll');
    const bulkActions = document.getElementById('bulkActions');
    const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
    const bulkDeselectBtn = document.getElementById('bulkDeselectBtn');
    const selectedCount = document.getElementById('selectedCount');
    const errorBanner = document.getElementById('errorBanner');
    const successBanner = document.getElementById('successBanner');

    // Pagination state
    let memCurrentPage = 0;
    let memCurrentQuery = '';
    let memCurrentTags = [];
    let memCurrentPeople = [];
    let memTotal = 0;
    const memPerPage = 20;
    let selectedMemories = new Set();

    // Voice dictation initialization
    function initializeDictation() {
      const voiceDict = new VoiceDictation();
      voiceDict.init('micButton', 'micStatus', 
        (transcription) => {
          memText.value = transcription;
          memForm.dispatchEvent(new Event('submit'));
        },
        (error) => console.error('Dictation error:', error)
      );
    }

    // Banner functions
    function showErrorBanner(message) {
      errorBanner.textContent = message;
      errorBanner.classList.add('show');
      successBanner.classList.remove('show');
      setTimeout(() => errorBanner.classList.remove('show'), 5000);
    }

    function showSuccessBanner(message) {
      successBanner.textContent = message;
      successBanner.classList.add('show');
      errorBanner.classList.remove('show');
      setTimeout(() => successBanner.classList.remove('show'), 3000);
    }

    // Filter chip functions
    function renderFilterChips() {
      filterChips.innerHTML = '';
      
      // Add tag chips
      memCurrentTags.forEach(tag => {
        const chip = document.createElement('div');
        chip.className = 'chip active removable';
        chip.innerHTML = `#${tag} <span class="remove" onclick="removeTagFilter('${tag}')">√ó</span>`;
        filterChips.appendChild(chip);
      });
      
      // Add people chips
      memCurrentPeople.forEach(person => {
        const chip = document.createElement('div');
        chip.className = 'chip active removable';
        chip.innerHTML = `@${person} <span class="remove" onclick="removePeopleFilter('${person}')">√ó</span>`;
        filterChips.appendChild(chip);
      });
    }

    function removeTagFilter(tag) {
      memCurrentTags = memCurrentTags.filter(t => t !== tag);
      memCurrentPage = 0;
      renderFilterChips();
      loadMemories();
    }

    function removePeopleFilter(person) {
      memCurrentPeople = memCurrentPeople.filter(p => p !== person);
      memCurrentPage = 0;
      renderFilterChips();
      loadMemories();
    }

    function extractAndShowFilters(memories) {
      // Extract unique tags and people from current results
      const allTags = new Set();
      const allPeople = new Set();
      
      memories.forEach(mem => {
        if (mem.tags) {
          const tags = mem.tags.split(' ');
          tags.forEach(tag => {
            if (tag.startsWith('#')) {
              allTags.add(tag.substring(1));
            } else if (tag.startsWith('@')) {
              allPeople.add(tag.substring(1));
            }
          });
        }
      });
      
      // Add clickable filter chips for available filters (only if not already filtered)
      allTags.forEach(tag => {
        if (!memCurrentTags.includes(tag)) {
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.textContent = `#${tag}`;
          chip.onclick = () => addTagFilter(tag);
          filterChips.appendChild(chip);
        }
      });
      
      allPeople.forEach(person => {
        if (!memCurrentPeople.includes(person)) {
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.textContent = `@${person}`;
          chip.onclick = () => addPeopleFilter(person);
          filterChips.appendChild(chip);
        }
      });
    }

    function addTagFilter(tag) {
      if (!memCurrentTags.includes(tag)) {
        memCurrentTags.push(tag);
        memCurrentPage = 0;
        renderFilterChips();
        loadMemories();
      }
    }

    function addPeopleFilter(person) {
      if (!memCurrentPeople.includes(person)) {
        memCurrentPeople.push(person);
        memCurrentPage = 0;
        renderFilterChips();
        loadMemories();
      }
    }

    // Bulk operations
    function updateBulkActions() {
      const count = selectedMemories.size;
      selectedCount.textContent = count;
      bulkActions.classList.toggle('show', count > 0);
      
      // Update select all checkbox state
      const allVisible = Array.from(memList.querySelectorAll('.memory-checkbox')).length;
      const allSelected = Array.from(memList.querySelectorAll('.memory-checkbox:checked')).length;
      selectAll.checked = allVisible > 0 && allSelected === allVisible;
      selectAll.indeterminate = allSelected > 0 && allSelected < allVisible;
    }

    function selectAllMemories() {
      const checkboxes = memList.querySelectorAll('.memory-checkbox');
      checkboxes.forEach(cb => {
        cb.checked = selectAll.checked;
        const memoryId = cb.dataset.memoryId;
        if (selectAll.checked) {
          selectedMemories.add(memoryId);
        } else {
          selectedMemories.delete(memoryId);
        }
      });
      updateBulkActions();
    }

    function deselectAllMemories() {
      selectedMemories.clear();
      const checkboxes = memList.querySelectorAll('.memory-checkbox');
      checkboxes.forEach(cb => cb.checked = false);
      selectAll.checked = false;
      selectAll.indeterminate = false;
      updateBulkActions();
    }

    // Memory functions
    async function loadMemories() {
      try {
        const params = new URLSearchParams();
        if (memCurrentQuery) {
          params.append('q', memCurrentQuery);
        }
        if (memCurrentTags.length > 0) {
          params.append('tags', memCurrentTags.join(','));
        }
        if (memCurrentPeople.length > 0) {
          params.append('people', memCurrentPeople.join(','));
        }
        params.append('offset', memCurrentPage * memPerPage);
        params.append('limit', memPerPage);

        const result = await window.memoriaAPI.request(`/memories?${params}`);
        const memories = result.items || [];
        memTotal = result.total || 0;
        
        renderList(memList, memories, 'memory');
        
        // Update pagination info
        const totalPages = Math.ceil(memTotal / memPerPage);
        memPageInfo.textContent = `Page ${memCurrentPage + 1} of ${totalPages} (${memTotal} total)`;
        memPrevBtn.disabled = memCurrentPage === 0;
        memNextBtn.disabled = memCurrentPage >= totalPages - 1;
        
        // Update filter chips
        renderFilterChips();
        extractAndShowFilters(memories);
        
        // Clear selections when loading new data
        selectedMemories.clear();
        updateBulkActions();
        
      } catch (error) {
        console.error('Failed to load memories:', error);
        showErrorBanner('Failed to load memories: ' + error.message);
      }
    }

    function renderList(el, items, type) {
      el.innerHTML = '';
      for (const it of items) {
        const li = document.createElement('li');
        li.dataset.id = it.id;
        li.dataset.type = type;
        
        const left = document.createElement('div'); 
        left.className = 'row';
        left.style.flex = '1';
        
        // Add checkbox for bulk selection
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'memory-checkbox';
        checkbox.dataset.memoryId = it.id;
        checkbox.checked = selectedMemories.has(it.id.toString());
        checkbox.onchange = (e) => {
          if (e.target.checked) {
            selectedMemories.add(it.id.toString());
          } else {
            selectedMemories.delete(it.id.toString());
          }
          updateBulkActions();
        };
        
        const contentContainer = document.createElement('div');
        contentContainer.style.flex = '1';
        
        const title = document.createElement('div'); 
        title.textContent = (it.text || it.title);
        title.className = 'content-text';
        
        const tags = document.createElement('div'); 
        tags.className = 'tags'; 
        tags.textContent = it.tags || '';
        
        contentContainer.append(title, tags);
        
        const editIcon = document.createElement('button');
        editIcon.className = 'edit-icon';
        editIcon.innerHTML = '‚úèÔ∏è';
        editIcon.title = 'Edit';
        editIcon.onclick = () => startEdit(li, type, it);
        
        left.append(checkbox, contentContainer, editIcon);
        
        const right = document.createElement('div'); 
        right.className = 'row';
        const deleteBtn = document.createElement('button'); 
        deleteBtn.className = 'pill'; 
        deleteBtn.textContent = 'üóëÔ∏è';
        deleteBtn.onclick = async () => { 
          if (confirm('Delete this memory?')) {
            try {
              await window.memoriaAPI.request(`/memories/${it.id}`, 'DELETE');
              await loadMemories();
              showSuccessBanner('Memory deleted successfully');
            } catch (error) {
              console.error('Failed to delete memory:', error);
              showErrorBanner('Failed to delete memory: ' + error.message);
            }
          }
        };
        right.append(deleteBtn);
        
        li.append(left, right);
        el.append(li);
      }
    }

    function startEdit(li, type, item) {
      // Find the content text element
      const contentText = li.querySelector('.content-text');
      const originalText = item.text || item.title;
      
      // Create inline input
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'inline-input';
      input.value = originalText;
      
      // Create action buttons
      const actions = document.createElement('div');
      actions.className = 'edit-actions';
      
      const saveBtn = document.createElement('button');
      saveBtn.textContent = '‚úì';
      saveBtn.className = 'save-btn';
      saveBtn.title = 'Save';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = '‚úï';
      cancelBtn.className = 'cancel-btn';
      cancelBtn.title = 'Cancel';
      
      actions.append(saveBtn, cancelBtn);
      
      // Replace content with input and actions
      const originalContent = contentText.innerHTML;
      contentText.innerHTML = '';
      contentText.appendChild(input);
      contentText.appendChild(actions);
      
      // Add editing class
      li.classList.add('editing');
      
      // Focus input and select all
      input.focus();
      input.select();
      
      // Save function
      const save = async () => {
        const newText = input.value.trim();
        if (newText && newText !== originalText) {
          li.classList.add('unsaved');
          try {
            await saveEdit(li, type, item.id, newText);
            showSuccessBanner('Memory updated successfully');
          } catch (error) {
            // Error handling is in saveEdit function
          }
        } else {
          cancel();
        }
      };
      
      // Cancel function
      const cancel = () => {
        contentText.innerHTML = originalContent;
        li.classList.remove('editing', 'unsaved');
      };
      
      // Event handlers
      saveBtn.onclick = save;
      cancelBtn.onclick = cancel;
      
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          save();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancel();
        }
      };
      
      // Auto-cancel on blur (with small delay to allow clicking save button)
      input.onblur = (e) => {
        setTimeout(() => {
          if (!actions.contains(document.activeElement)) {
            cancel();
          }
        }, 150);
      };
    }

    async function saveEdit(li, type, id, newValue) {
      try {
        if (type === 'memory') {
          await window.memoriaAPI.request(`/memories/${id}`, 'PATCH', { text: newValue });
        }
        await loadMemories();
      } catch (error) {
        console.error('Failed to save edit:', error);
        showErrorBanner('Failed to save edit: ' + error.message);
      }
    }

    // Event handlers
    memForm.onsubmit = async (e) => {
      e.preventDefault();
      const text = memText.value.trim();
      if (!text) return;
      
      try {
        const result = await window.memoriaAPI.request('/memories', 'POST', { text });
        memText.value = '';
        
        if (result && result.queued) {
          showSuccessBanner('Memory queued for when online');
        } else {
          await loadMemories();
          showSuccessBanner('Memory added successfully');
        }
      } catch (error) {
        console.error('Failed to add memory:', error);
        showErrorBanner('Failed to add memory: ' + error.message);
      }
    };

    memSearchBtn.onclick = async () => {
      memCurrentQuery = memSearch.value.trim();
      memCurrentPage = 0;
      await loadMemories();
    };

    memClearBtn.onclick = async () => {
      memSearch.value = '';
      memCurrentQuery = '';
      memCurrentTags = [];
      memCurrentPeople = [];
      memCurrentPage = 0;
      await loadMemories();
    };

    memPrevBtn.onclick = async () => {
      if (memCurrentPage > 0) {
        memCurrentPage--;
        await loadMemories();
      }
    };

    memNextBtn.onclick = async () => {
      memCurrentPage++;
      await loadMemories();
    };

    // Allow enter key to search
    memSearch.onkeydown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        memSearchBtn.click();
      }
    };

    // Bulk operations event handlers
    selectAll.onchange = selectAllMemories;
    bulkDeselectBtn.onclick = deselectAllMemories;
    
    bulkDeleteBtn.onclick = async () => {
      if (selectedMemories.size === 0) return;
      
      const count = selectedMemories.size;
      if (!confirm(`Delete ${count} selected memories? This cannot be undone.`)) {
        return;
      }
      
      let successCount = 0;
      let errorCount = 0;
      
      for (const memoryId of selectedMemories) {
        try {
          await window.memoriaAPI.request(`/memories/${memoryId}`, 'DELETE');
          successCount++;
        } catch (error) {
          console.error(`Failed to delete memory ${memoryId}:`, error);
          errorCount++;
        }
      }
      
      // Clear selections and reload
      selectedMemories.clear();
      await loadMemories();
      
      // Show results
      if (errorCount === 0) {
        showSuccessBanner(`Successfully deleted ${successCount} memories`);
      } else {
        showErrorBanner(`Deleted ${successCount} memories, ${errorCount} failed`);
      }
    };

    // Load initial data
    loadMemories();

    // Initialize dictation after page load
    document.addEventListener('DOMContentLoaded', initializeDictation);

    // Global functions for onclick handlers
    window.removeTagFilter = removeTagFilter;
    window.removePeopleFilter = removePeopleFilter;
    window.addTagFilter = addTagFilter;
    window.addPeopleFilter = addPeopleFilter;
  </script>
</body>
</html>